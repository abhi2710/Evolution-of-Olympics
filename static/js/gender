let init_scatter = function(svg, type, year, region){

    svg.selectAll('*').remove();

    let height = parseInt(svg.style("height")),
        width = parseInt(svg.style("width"))


    let xScale = d3.scaleLinear()
		.range([0, width]);

	let yScale = d3.scaleLinear()
		.range([height, 0]);

	// square root scale.
	let radius = d3.scaleSqrt()
		.range([2,5]);

	// the axes are much cleaner and easier now. No need to rotate and orient the axis, just call axisBottom, axisLeft etc.
	let xAxis = d3.axisBottom()
		.scale(xScale);

	let yAxis = d3.axisLeft()
		.scale(yScale);

	// again scaleOrdinal
	let color = d3.scaleOrdinal(d3.schemeCategory20);


    let url = `/gender/${year}/${region}`;
	$.get(url, function(data) {
		if (data) {
		    data = JSON.parse(data);
		    xScale.domain(d3.extent(data, function(d){
			    return d.SepalLength;
		    })).nice();

		    yScale.domain(d3.extent(data, function(d){
			    return d.SepalWidth;
		    })).nice();

		    radius.domain(d3.extent(data, function(d){
			    return d.PetalLength;
		    })).nice();


		    svg.append('g')
			.attr('transform', 'translate(0,' + height + ')')
			.attr('class', 'x axis')
			.call(xAxis);

            // y-axis is translated to (0,0)
            svg.append('g')
                .attr('transform', 'translate(0,0)')
                .attr('class', 'y axis')
                .call(yAxis);


            let bubble = svg.selectAll('.bubble')
                .data(data)
                .enter().append('circle')
                .attr('class', 'bubble')
                .attr('cx', function(d){return xScale(d.x);})
                .attr('cy', function(d){ return yScale(d.ratio); })
                .attr('r', function(d){ return radius(d.ratio); })
                .style('fill', function(d){ return color(d.ratio); });

//            bubble.append('title')
//                .attr('x', function(d){ return radius(d.PetalLength); })
//                .text(function(d){
//                    return d.Species;
//                });

            // adding label. For x-axis, it's at (10, 10), and for y-axis at (width, height-10).
            svg.append('text')
                .attr('x', 10)
                .attr('y', 10)
                .attr('class', 'label')
                .text('Sepal Width');


            svg.append('text')
                .attr('x', width)
                .attr('y', height - 10)
                .attr('text-anchor', 'end')
                .attr('class', 'label')
                .text('Sepal Length');

//            // I feel I understand legends much better now.
//            // define a group element for each color i, and translate it to (0, i * 20).
//            let legend = svg.selectAll('legend')
//                .data(color.domain())
//                .enter().append('g')
//                .attr('class', 'legend')
//                .attr('transform', function(d,i){ return 'translate(0,' + i * 20 + ')'; });
//
//            // give x value equal to the legend elements.
//            // no need to define a function for fill, this is automatically fill by color.
//            legend.append('rect')
//                .attr('x', width)
//                .attr('width', 18)
//                .attr('height', 18)
//                .style('fill', color);
//
//            // add text to the legend elements.
//            // rects are defined at x value equal to width, we define text at width - 6, this will print name of the legends before the rects.
//            legend.append('text')
//                .attr('x', width - 6)
//                .attr('y', 9)
//                .attr('dy', '.35em')
//                .style('text-anchor', 'end')
//                .text(function(d){ return d; });


//            // d3 has a filter fnction similar to filter function in JS. Here it is used to filter d3 components.
//            legend.on('click', function(type){
//                d3.selectAll('.bubble')
//                    .style('opacity', 0.15)
//                    .filter(function(d){
//                        return d.Species == type;
//                    })
//                    .style('opacity', 1);
//            })

		}
	}

}